// Generated SystemVerilog testbench
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go
#include "topi.cc" // CXXRTL generated header for the module
// You might need a common CXXRTL include, e.g.:
// #include "cxxrtl_lib.h" 

#include <fstream>
#include <iostream>
#include <iomanip> // Required for std::setw and std::setfill
#include <cstdint>
#include <string>
#include <sstream> // Required for std::hex and std::stringstream

// Assuming the CXXRTL-generated code uses a 'cxxrtl_design' namespace 
// and prefixes the module class with 'p_'. Adjust if your CXXRTL setup differs.
int main(int argc, char** argv) {
    cxxrtl_design::p_topi topi_i; // DUT instance: cxxrtl_design::p_ (2. cxxrtlMangledModuleName) (3. baseModuleNameForInstance)_i;

    // Declare input variables
    cxxrtl::value<96> clkin_data;
    cxxrtl::value<192> in_data;
 // 4. Input declarations
    
    // Read input values
    std::ifstream clkin_data_file("input_clkin_data.hex");
    if (!clkin_data_file.is_open()) {
        std::cerr << "Failed to open input file for clkin_data: input_clkin_data.hex" << std::endl;
        return 1;
    }
    std::string clkin_data_hex_str;
    clkin_data_file >> clkin_data_hex_str;
    if (clkin_data_file.fail() && !clkin_data_file.eof()) {
        std::cerr << "Failed to read hex string for clkin_data from input file: input_clkin_data.hex" << std::endl;
        clkin_data_file.close();
        return 1;
    }
    // Parse clkin_data_hex_str into clkin_data.data
    // clkin_data is cxxrtl::value<96>. Chunks = 2 (assuming 64-bit chunks). Bits per chunk = 64. Hex chars per chunk = 16.
    // Total hex chars for 96 bits = 24.
    // Hex string is MSB first. CXXRTL data array is LSB first (data[0] is LSB chunk).
    size_t total_hex_chars_for_clkin_data = 96 / 4;
    if (clkin_data_hex_str.length() < total_hex_chars_for_clkin_data) {
        clkin_data_hex_str.insert(0, total_hex_chars_for_clkin_data - clkin_data_hex_str.length(), '0');
    } else if (clkin_data_hex_str.length() > total_hex_chars_for_clkin_data) {
        clkin_data_hex_str = clkin_data_hex_str.substr(clkin_data_hex_str.length() - total_hex_chars_for_clkin_data);
    }

    const size_t num_chunks_for_clkin_data = cxxrtl::value<96>::chunks;
    const size_t hex_chars_per_chunk_for_clkin_data = cxxrtl::value<96>::chunk::bits / 4;

    for (size_t i = 0; i < num_chunks_for_clkin_data; ++i) {
        size_t data_idx = i; // LSB chunk for data is data[0]
        size_t str_offset = (num_chunks_for_clkin_data - 1 - i) * hex_chars_per_chunk_for_clkin_data; // Corresponding part in MSB-first hex string
        std::string chunk_hex_str = clkin_data_hex_str.substr(str_offset, hex_chars_per_chunk_for_clkin_data);
        clkin_data.data[data_idx] = std::stoull(chunk_hex_str, nullptr, 16);
    }
    clkin_data_file.close();

    std::ifstream in_data_file("input_in_data.hex");
    if (!in_data_file.is_open()) {
        std::cerr << "Failed to open input file for in_data: input_in_data.hex" << std::endl;
        return 1;
    }
    std::string in_data_hex_str;
    in_data_file >> in_data_hex_str;
    if (in_data_file.fail() && !in_data_file.eof()) {
        std::cerr << "Failed to read hex string for in_data from input file: input_in_data.hex" << std::endl;
        in_data_file.close();
        return 1;
    }
    // Parse in_data_hex_str into in_data.data
    // in_data is cxxrtl::value<192>. Chunks = 3 (assuming 64-bit chunks). Bits per chunk = 64. Hex chars per chunk = 16.
    // Total hex chars for 192 bits = 48.
    // Hex string is MSB first. CXXRTL data array is LSB first (data[0] is LSB chunk).
    size_t total_hex_chars_for_in_data = 192 / 4;
    if (in_data_hex_str.length() < total_hex_chars_for_in_data) {
        in_data_hex_str.insert(0, total_hex_chars_for_in_data - in_data_hex_str.length(), '0');
    } else if (in_data_hex_str.length() > total_hex_chars_for_in_data) {
        in_data_hex_str = in_data_hex_str.substr(in_data_hex_str.length() - total_hex_chars_for_in_data);
    }

    const size_t num_chunks_for_in_data = cxxrtl::value<192>::chunks;
    const size_t hex_chars_per_chunk_for_in_data = cxxrtl::value<192>::chunk::bits / 4;

    for (size_t i = 0; i < num_chunks_for_in_data; ++i) {
        size_t data_idx = i; // LSB chunk for data is data[0]
        size_t str_offset = (num_chunks_for_in_data - 1 - i) * hex_chars_per_chunk_for_in_data; // Corresponding part in MSB-first hex string
        std::string chunk_hex_str = in_data_hex_str.substr(str_offset, hex_chars_per_chunk_for_in_data);
        in_data.data[data_idx] = std::stoull(chunk_hex_str, nullptr, 16);
    }
    in_data_file.close();

 // 5. Input reads
    
    // Apply inputs to DUT
    topi_i.p_clkin__data = clkin_data;
    topi_i.p_in__data = in_data;
 // 6. Input application
 // 6. Input application
    
    // Handle reset, clock toggling, and evaluation

    // Clock toggling
    for (int cycle = 0; cycle < 10; cycle++) {
        topi_i.p_clkin__data = cxxrtl::value<96>{0u};
        topi_i.step(); // clock low
        topi_i.p_clkin__data = cxxrtl::value<96>{1u};
        topi_i.step(); // clock high
    }

    // Extra evaluation steps to ensure all logic settles
    topi_i.step();
    topi_i.step();
    topi_i.step();
 // 7. Clock handling and evaluation code
    
    // Write outputs from DUT
    std::ofstream out_data_file("output_out_data.hex");
    if (!out_data_file.is_open()) {
        std::cerr << "Failed to open output file for out_data: output_out_data.hex" << std::endl;
        return 1;
    }
    for (int i = 191; i >= 0; --i) {
        out_data_file << (topi_i.p_out__data.bit(i) ? '1' : '0');
    }
    out_data_file << std::endl;
    out_data_file.close();

    std::ofstream inj_param_out_547_file("output_inj_param_out_547.hex");
    if (!inj_param_out_547_file.is_open()) {
        std::cerr << "Failed to open output file for inj_param_out_547: output_inj_param_out_547.hex" << std::endl;
        return 1;
    }
    uint8_t value_inj_param_out_547 = topi_i.p_inj__param__out__547.get<uint8_t>();
    for (int i = 7; i >= 0; i--) {
        inj_param_out_547_file << ((value_inj_param_out_547 >> i) & 1);
    }
    inj_param_out_547_file << std::endl; // Add a newline at the end of the bit string
    inj_param_out_547_file.close();

 // 8. Output writes
    
    // CXXRTL objects on the stack are cleaned up automatically
    return 0;
}
