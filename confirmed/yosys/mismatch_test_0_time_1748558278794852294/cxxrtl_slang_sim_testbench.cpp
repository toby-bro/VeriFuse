// Generated SystemVerilog testbench
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go
#include "stmt_if_task.cc" // CXXRTL generated header for the module
// You might need a common CXXRTL include, e.g.:
// #include "cxxrtl_lib.h" 

#include <fstream>
#include <iostream>
#include <iomanip> // Required for std::setw and std::setfill
#include <cstdint>
#include <string>
#include <sstream> // Required for std::hex and std::stringstream

// Assuming the CXXRTL-generated code uses a 'cxxrtl_design' namespace 
// and prefixes the module class with 'p_'. Adjust if your CXXRTL setup differs.
int main(int argc, char** argv) {
    cxxrtl_design::p_stmt__if__task stmt_if_task_i; // DUT instance: cxxrtl_design::p_ (2. cxxrtlMangledModuleName) (3. baseModuleNameForInstance)_i;

    // Declare input variables
    uint8_t in_val_m6;
    bool condition_m6;
 // 4. Input declarations
    
    // Read input values
    std::ifstream in_val_m6_file("input_in_val_m6.hex");
    if (!in_val_m6_file.is_open()) {
        std::cerr << "Failed to open input file for in_val_m6: input_in_val_m6.hex" << std::endl;
        return 1;
    }
    std::string in_val_m6_hex_str;
    in_val_m6_file >> in_val_m6_hex_str;
    if (in_val_m6_file.fail() && !in_val_m6_file.eof()) {
        std::cerr << "Failed to read hex string for in_val_m6 from input file: input_in_val_m6.hex" << std::endl;
        in_val_m6_file.close();
        return 1;
    }
    std::stringstream ss_in_val_m6;
    ss_in_val_m6 << std::hex << in_val_m6_hex_str;
    unsigned int temp_in_val_m6;
    if (!(ss_in_val_m6 >> temp_in_val_m6)) {
        std::cerr << "Failed to parse hex value for in_val_m6: " << in_val_m6_hex_str << std::endl;
        in_val_m6_file.close();
        return 1;
    }
    in_val_m6 = static_cast<uint8_t>(temp_in_val_m6);
    in_val_m6_file.close();

    std::ifstream condition_m6_file("input_condition_m6.hex");
    if (!condition_m6_file.is_open()) {
        std::cerr << "Failed to open input file for condition_m6: input_condition_m6.hex" << std::endl;
        return 1;
    }
    std::string condition_m6_hex_str;
    condition_m6_file >> condition_m6_hex_str;
    if (condition_m6_file.fail() && !condition_m6_file.eof()) {
        std::cerr << "Failed to read hex string for condition_m6 from input file: input_condition_m6.hex" << std::endl;
        condition_m6_file.close();
        return 1;
    }
    std::stringstream ss_condition_m6;
    ss_condition_m6 << std::hex << condition_m6_hex_str;
    unsigned int temp_condition_m6;
    if (!(ss_condition_m6 >> temp_condition_m6)) {
        std::cerr << "Failed to parse hex value for condition_m6: " << condition_m6_hex_str << std::endl;
        condition_m6_file.close();
        return 1;
    }
    condition_m6 = static_cast<bool>(temp_condition_m6);
    condition_m6_file.close();

 // 5. Input reads
    
    // Apply inputs to DUT
    stmt_if_task_i.p_in__val__m6.set<uint8_t>(in_val_m6);
    stmt_if_task_i.p_condition__m6.set<bool>(condition_m6);
 // 6. Input application
 // 6. Input application
    
    // Handle reset, clock toggling, and evaluation

    // No clock found, performing bounded steps for combinational logic to settle
    for (int settle_step = 0; settle_step < 20; settle_step++) {
        stmt_if_task_i.step();
    }
 // 7. Clock handling and evaluation code
    
    // Write outputs from DUT
    std::ofstream out_val_m6_file("output_out_val_m6.hex");
    if (!out_val_m6_file.is_open()) {
        std::cerr << "Failed to open output file for out_val_m6: output_out_val_m6.hex" << std::endl;
        return 1;
    }
    uint8_t value_out_val_m6 = stmt_if_task_i.p_out__val__m6.get<uint8_t>();
    for (int i = 7; i >= 0; i--) {
        out_val_m6_file << ((value_out_val_m6 >> i) & 1);
    }
    out_val_m6_file << std::endl; // Add a newline at the end of the bit string
    out_val_m6_file.close();

 // 8. Output writes
    
    // CXXRTL objects on the stack are cleaned up automatically
    return 0;
}
