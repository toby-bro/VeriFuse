// Generated SystemVerilog testbench
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go
#include "expr_postsub_comb.cc" // CXXRTL generated header for the module
// You might need a common CXXRTL include, e.g.:
// #include "cxxrtl_lib.h" 

#include <fstream>
#include <iostream>
#include <iomanip> // Required for std::setw and std::setfill
#include <cstdint>
#include <string>
#include <sstream> // Required for std::hex and std::stringstream

// Assuming the CXXRTL-generated code uses a 'cxxrtl_design' namespace 
// and prefixes the module class with 'p_'. Adjust if your CXXRTL setup differs.
int main(int argc, char** argv) {
    cxxrtl_design::p_expr__postsub__comb expr_postsub_comb_i; // DUT instance: cxxrtl_design::p_ (2. cxxrtlMangledModuleName) (3. baseModuleNameForInstance)_i;

    // Declare input variables
    uint8_t sub_val_m2;
    uint8_t in_val_m2;
 // 4. Input declarations
    
    // Read input values
    std::ifstream sub_val_m2_file("input_sub_val_m2.hex");
    if (!sub_val_m2_file.is_open()) {
        std::cerr << "Failed to open input file for sub_val_m2: input_sub_val_m2.hex" << std::endl;
        return 1;
    }
    std::string sub_val_m2_hex_str;
    sub_val_m2_file >> sub_val_m2_hex_str;
    if (sub_val_m2_file.fail() && !sub_val_m2_file.eof()) {
        std::cerr << "Failed to read hex string for sub_val_m2 from input file: input_sub_val_m2.hex" << std::endl;
        sub_val_m2_file.close();
        return 1;
    }
    std::stringstream ss_sub_val_m2;
    ss_sub_val_m2 << std::hex << sub_val_m2_hex_str;
    unsigned int temp_sub_val_m2;
    if (!(ss_sub_val_m2 >> temp_sub_val_m2)) {
        std::cerr << "Failed to parse hex value for sub_val_m2: " << sub_val_m2_hex_str << std::endl;
        sub_val_m2_file.close();
        return 1;
    }
    sub_val_m2 = static_cast<uint8_t>(temp_sub_val_m2);
    sub_val_m2_file.close();

    std::ifstream in_val_m2_file("input_in_val_m2.hex");
    if (!in_val_m2_file.is_open()) {
        std::cerr << "Failed to open input file for in_val_m2: input_in_val_m2.hex" << std::endl;
        return 1;
    }
    std::string in_val_m2_hex_str;
    in_val_m2_file >> in_val_m2_hex_str;
    if (in_val_m2_file.fail() && !in_val_m2_file.eof()) {
        std::cerr << "Failed to read hex string for in_val_m2 from input file: input_in_val_m2.hex" << std::endl;
        in_val_m2_file.close();
        return 1;
    }
    std::stringstream ss_in_val_m2;
    ss_in_val_m2 << std::hex << in_val_m2_hex_str;
    unsigned int temp_in_val_m2;
    if (!(ss_in_val_m2 >> temp_in_val_m2)) {
        std::cerr << "Failed to parse hex value for in_val_m2: " << in_val_m2_hex_str << std::endl;
        in_val_m2_file.close();
        return 1;
    }
    in_val_m2 = static_cast<uint8_t>(temp_in_val_m2);
    in_val_m2_file.close();

 // 5. Input reads
    
    // Apply inputs to DUT
    expr_postsub_comb_i.p_sub__val__m2.set<uint8_t>(sub_val_m2);
    expr_postsub_comb_i.p_in__val__m2.set<uint8_t>(in_val_m2);
 // 6. Input application
 // 6. Input application
    
    // Handle reset, clock toggling, and evaluation

    // No clock found, performing bounded steps for combinational logic to settle
    for (int settle_step = 0; settle_step < 20; settle_step++) {
        expr_postsub_comb_i.step();
    }
 // 7. Clock handling and evaluation code
    
    // Add massive delay to ensure all signals have completely settled
    // This helps eliminate any potential race conditions before reading outputs
    for (int massive_delay = 0; massive_delay < 10000; massive_delay++) {
        expr_postsub_comb_i.step();
    }
    
    // Write outputs from DUT
    std::ofstream out_diff_m2_file("output_out_diff_m2.hex");
    if (!out_diff_m2_file.is_open()) {
        std::cerr << "Failed to open output file for out_diff_m2: output_out_diff_m2.hex" << std::endl;
        return 1;
    }
    uint8_t value_out_diff_m2 = expr_postsub_comb_i.p_out__diff__m2.get<uint8_t>();
    for (int i = 7; i >= 0; i--) {
        out_diff_m2_file << ((value_out_diff_m2 >> i) & 1);
    }
    out_diff_m2_file << std::endl; // Add a newline at the end of the bit string
    out_diff_m2_file.close();

    std::ofstream var_out_m2_file("output_var_out_m2.hex");
    if (!var_out_m2_file.is_open()) {
        std::cerr << "Failed to open output file for var_out_m2: output_var_out_m2.hex" << std::endl;
        return 1;
    }
    uint8_t value_var_out_m2 = expr_postsub_comb_i.p_var__out__m2.get<uint8_t>();
    for (int i = 7; i >= 0; i--) {
        var_out_m2_file << ((value_var_out_m2 >> i) & 1);
    }
    var_out_m2_file << std::endl; // Add a newline at the end of the bit string
    var_out_m2_file.close();

 // 8. Output writes
    
    // CXXRTL objects on the stack are cleaned up automatically
    return 0;
}
