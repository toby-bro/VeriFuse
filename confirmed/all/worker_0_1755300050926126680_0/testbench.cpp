// Generated C++ testbench for CXXRTL
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go
#include "class_user.cc" // CXXRTL generated header for the module

#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdint>
#include <string>
#include <sstream>
#include <type_traits>

// Template helpers to detect and work with both value<> and wire<> types
template<typename T>
struct has_curr {
    template<typename U>
    static auto test(int) -> decltype(std::declval<U>().curr, std::true_type{});
    template<typename>
    static std::false_type test(...);
    using type = decltype(test<T>(0));
    static constexpr bool value = type::value;
};

// Helper function to get port value - works with both value<> and wire<>
template<typename T, typename PortType>
typename std::enable_if<has_curr<PortType>::value, T>::type
_get_port_value(const PortType& port) {
    return port.curr.template get<T>();
}

template<typename T, typename PortType>
typename std::enable_if<!has_curr<PortType>::value, T>::type
_get_port_value(const PortType& port) {
    return port.template get<T>();
}

// Helper function to get port bit - works with both value<> and wire<>
template<typename PortType>
typename std::enable_if<has_curr<PortType>::value, bool>::type
_get_port_value(const PortType& port, int bit) {
    return port.curr.bit(bit);
}

template<typename PortType>
typename std::enable_if<!has_curr<PortType>::value, bool>::type
_get_port_value(const PortType& port, int bit) {
    return port.bit(bit);
}

// Helper function to get wide port value - works with both value<> and wire<>
template<typename PortType>
auto _get_port_value_wide(const PortType& port) -> typename std::enable_if<has_curr<PortType>::value, decltype(port.curr)>::type {
    return port.curr;
}

template<typename PortType>
auto _get_port_value_wide(const PortType& port) -> typename std::enable_if<!has_curr<PortType>::value, PortType>::type {
    return port;
}

// Helper function to set port value - works with both value<> and wire<>
template<typename T, typename PortType>
typename std::enable_if<has_curr<PortType>::value, void>::type
_set_port_value(PortType& port, T value) {
    port.next.template set<T>(value);
}

template<typename T, typename PortType>
typename std::enable_if<!has_curr<PortType>::value, void>::type
_set_port_value(PortType& port, T value) {
    port.template set<T>(value);
}

// Helper function to set wide port value - works with both value<> and wire<>
template<typename PortType, typename ValueType>
typename std::enable_if<has_curr<PortType>::value, void>::type
_set_port_value_wide(PortType& port, const ValueType& value) {
    port.next = value;
}

template<typename PortType, typename ValueType>
typename std::enable_if<!has_curr<PortType>::value, void>::type
_set_port_value_wide(PortType& port, const ValueType& value) {
    port = value;
}

int main(int argc, char** argv) {
    cxxrtl_design::p_class__user class_user_i; // DUT instance

    // Declare input variables
    bool clk;
    uint32_t data_i;
    uint8_t id_i;
    uint32_t inj_data_in_1755300051244_81;
    bool rst;


    // Read input values
    std::ifstream clk_file("input_clk.hex");
    if (!clk_file.is_open()) {
        std::cerr << "Failed to open input file for clk: input_clk.hex" << std::endl;
        return 1;
    }
    std::string clk_hex_str;
    clk_file >> clk_hex_str;
    if (clk_file.fail() && !clk_file.eof()) {
        std::cerr << "Failed to read hex string for clk from input file: input_clk.hex" << std::endl;
        clk_file.close();
        return 1;
    }
    std::stringstream ss_clk;
    ss_clk << std::hex << clk_hex_str;
    unsigned int temp_clk;
    if (!(ss_clk >> temp_clk)) {
        std::cerr << "Failed to parse hex value for clk: " << clk_hex_str << std::endl;
        clk_file.close();
        return 1;
    }
    clk = static_cast<bool>(temp_clk);
    clk_file.close();

    std::ifstream data_i_file("input_data_i.hex");
    if (!data_i_file.is_open()) {
        std::cerr << "Failed to open input file for data_i: input_data_i.hex" << std::endl;
        return 1;
    }
    std::string data_i_hex_str;
    data_i_file >> data_i_hex_str;
    if (data_i_file.fail() && !data_i_file.eof()) {
        std::cerr << "Failed to read hex string for data_i from input file: input_data_i.hex" << std::endl;
        data_i_file.close();
        return 1;
    }
    std::stringstream ss_data_i;
    ss_data_i << std::hex << data_i_hex_str;
    if (!(ss_data_i >> data_i)) {
        std::cerr << "Failed to parse hex value for data_i: " << data_i_hex_str << std::endl;
        data_i_file.close();
        return 1;
    }
    data_i_file.close();

    std::ifstream id_i_file("input_id_i.hex");
    if (!id_i_file.is_open()) {
        std::cerr << "Failed to open input file for id_i: input_id_i.hex" << std::endl;
        return 1;
    }
    std::string id_i_hex_str;
    id_i_file >> id_i_hex_str;
    if (id_i_file.fail() && !id_i_file.eof()) {
        std::cerr << "Failed to read hex string for id_i from input file: input_id_i.hex" << std::endl;
        id_i_file.close();
        return 1;
    }
    std::stringstream ss_id_i;
    ss_id_i << std::hex << id_i_hex_str;
    unsigned int temp_id_i;
    if (!(ss_id_i >> temp_id_i)) {
        std::cerr << "Failed to parse hex value for id_i: " << id_i_hex_str << std::endl;
        id_i_file.close();
        return 1;
    }
    id_i = static_cast<uint8_t>(temp_id_i);
    id_i_file.close();

    std::ifstream inj_data_in_1755300051244_81_file("input_inj_data_in_1755300051244_81.hex");
    if (!inj_data_in_1755300051244_81_file.is_open()) {
        std::cerr << "Failed to open input file for inj_data_in_1755300051244_81: input_inj_data_in_1755300051244_81.hex" << std::endl;
        return 1;
    }
    std::string inj_data_in_1755300051244_81_hex_str;
    inj_data_in_1755300051244_81_file >> inj_data_in_1755300051244_81_hex_str;
    if (inj_data_in_1755300051244_81_file.fail() && !inj_data_in_1755300051244_81_file.eof()) {
        std::cerr << "Failed to read hex string for inj_data_in_1755300051244_81 from input file: input_inj_data_in_1755300051244_81.hex" << std::endl;
        inj_data_in_1755300051244_81_file.close();
        return 1;
    }
    std::stringstream ss_inj_data_in_1755300051244_81;
    ss_inj_data_in_1755300051244_81 << std::hex << inj_data_in_1755300051244_81_hex_str;
    if (!(ss_inj_data_in_1755300051244_81 >> inj_data_in_1755300051244_81)) {
        std::cerr << "Failed to parse hex value for inj_data_in_1755300051244_81: " << inj_data_in_1755300051244_81_hex_str << std::endl;
        inj_data_in_1755300051244_81_file.close();
        return 1;
    }
    inj_data_in_1755300051244_81_file.close();

    std::ifstream rst_file("input_rst.hex");
    if (!rst_file.is_open()) {
        std::cerr << "Failed to open input file for rst: input_rst.hex" << std::endl;
        return 1;
    }
    std::string rst_hex_str;
    rst_file >> rst_hex_str;
    if (rst_file.fail() && !rst_file.eof()) {
        std::cerr << "Failed to read hex string for rst from input file: input_rst.hex" << std::endl;
        rst_file.close();
        return 1;
    }
    std::stringstream ss_rst;
    ss_rst << std::hex << rst_hex_str;
    unsigned int temp_rst;
    if (!(ss_rst >> temp_rst)) {
        std::cerr << "Failed to parse hex value for rst: " << rst_hex_str << std::endl;
        rst_file.close();
        return 1;
    }
    rst = static_cast<bool>(temp_rst);
    rst_file.close();



    // Apply inputs to DUT
    _set_port_value<bool>(class_user_i.p_clk, clk);
    _set_port_value<uint32_t>(class_user_i.p_data__i, data_i);
    _set_port_value<uint8_t>(class_user_i.p_id__i, id_i);
    _set_port_value<bool>(class_user_i.p_rst, rst);
    // Input application


    // Handle reset, clock toggling, and evaluation

    // Toggle reset signal p_rst
    class_user_i.p_rst.set<bool>(true); // Assert reset (active high)
    class_user_i.step(); // Step to propagate reset assertion
    class_user_i.p_rst.set<bool>(false); // De-assert reset
    class_user_i.step(); // Step to propagate reset de-assertion
    class_user_i.step(); // Extra step for settling after reset

    // Clock toggling with bounded cycles to prevent infinite loops
    for (int cycle = 0; cycle < 50; cycle++) {
        _set_port_value<bool>(class_user_i.p_clk, false);
        class_user_i.step(); // clock low
        _set_port_value<bool>(class_user_i.p_clk, true);
        class_user_i.step(); // clock high
    }

    // Bounded evaluation steps to ensure all logic settles (max 20 steps)
    for (int settle_step = 0; settle_step < 20; settle_step++) {
        class_user_i.step();
    }


    // Write outputs from DUT
    std::ofstream crc_o_file("output_crc_o.hex");
    if (!crc_o_file.is_open()) {
        std::cerr << "Failed to open output file for crc_o: output_crc_o.hex" << std::endl;
        return 1;
    }
    for (int i = 15; i >= 0; --i) {
        crc_o_file << (_get_port_value(class_user_i.p_crc__o, i) ? '1' : '0');
    }
    crc_o_file << std::endl;
    crc_o_file.close();

    std::ofstream inj_data_out_1755300051244_814_file("output_inj_data_out_1755300051244_814.hex");
    if (!inj_data_out_1755300051244_814_file.is_open()) {
        std::cerr << "Failed to open output file for inj_data_out_1755300051244_814: output_inj_data_out_1755300051244_814.hex" << std::endl;
        return 1;
    }
    for (int i = 31; i >= 0; --i) {
        inj_data_out_1755300051244_814_file << (_get_port_value(class_user_i.p_inj__data__out__1755300051244__814, i) ? '1' : '0');
    }
    inj_data_out_1755300051244_814_file << std::endl;
    inj_data_out_1755300051244_814_file.close();



    return 0;
}
