package testgen

// svTestbenchTemplate is the template for SystemVerilog testbenches
// Parameters:
// 1. Include directive for the mocked module
// 2. Declarations
// 3. Module instance
// 4. Input count
// 5. Input read code
// 6. Reset toggle code
// 7. Clock toggle code
// 8. Output count
// 9. Output write code
const svTestbenchTemplate = `// Generated SystemVerilog testbench
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go

module top;
%s
%s

    initial begin
        string line;
        int fd;
        int status;

        // Read %d input files
%s

        // Toggle reset if a reset signal was identified
%s

        // Toggle clock signals
%s

        // Allow module to process and settle
        #10; // Increased delay for settling
        
        // Additional clock cycles to ensure all sequential logic settles
        #10;
        #10;

        // Write %d output files
%s

        $finish;
    end
endmodule`

// cxxrtlTestbenchTemplate is the template for C++ testbenches
// Parameters:
// 1. Module name (for include directive, e.g., "my_module")
// 2. Module name (for CXXRTL class name, e.g., "my_module" -> cxxrtl_design::p_my_module)
// 3. Module instance name (e.g., "my_module_i")
// 4. Input declarations
// 5. Input reads
// 6. Input application
// 7. Clock handling and evaluation code
// 8. Output writes
const cxxrtlTestbenchTemplate = `// Generated C++ testbench for CXXRTL
// Do not edit this file directly : edit the template in internal/testgen/testbenches.go and generator.go
#include "%s.cc" // CXXRTL generated header for the module

#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdint>
#include <string>
#include <sstream>
#include <type_traits>

// Template helpers to detect and work with both value<> and wire<> types
template<typename T>
struct has_curr {
    template<typename U>
    static auto test(int) -> decltype(std::declval<U>().curr, std::true_type{});
    template<typename>
    static std::false_type test(...);
    using type = decltype(test<T>(0));
    static constexpr bool value = type::value;
};

// Helper function to get port value - works with both value<> and wire<>
template<typename T, typename PortType>
typename std::enable_if<has_curr<PortType>::value, T>::type
_get_port_value(const PortType& port) {
    return port.curr.template get<T>();
}

template<typename T, typename PortType>
typename std::enable_if<!has_curr<PortType>::value, T>::type
_get_port_value(const PortType& port) {
    return port.template get<T>();
}

// Helper function to get port bit - works with both value<> and wire<>
template<typename PortType>
typename std::enable_if<has_curr<PortType>::value, bool>::type
_get_port_value(const PortType& port, int bit) {
    return port.curr.bit(bit);
}

template<typename PortType>
typename std::enable_if<!has_curr<PortType>::value, bool>::type
_get_port_value(const PortType& port, int bit) {
    return port.bit(bit);
}

// Helper function to get wide port value - works with both value<> and wire<>
template<typename PortType>
auto _get_port_value_wide(const PortType& port) -> typename std::enable_if<has_curr<PortType>::value, decltype(port.curr)>::type {
    return port.curr;
}

template<typename PortType>
auto _get_port_value_wide(const PortType& port) -> typename std::enable_if<!has_curr<PortType>::value, PortType>::type {
    return port;
}

// Helper function to set port value - works with both value<> and wire<>
template<typename T, typename PortType>
typename std::enable_if<has_curr<PortType>::value, void>::type
_set_port_value(PortType& port, T value) {
    port.next.template set<T>(value);
}

template<typename T, typename PortType>
typename std::enable_if<!has_curr<PortType>::value, void>::type
_set_port_value(PortType& port, T value) {
    port.template set<T>(value);
}

// Helper function to set wide port value - works with both value<> and wire<>
template<typename PortType, typename ValueType>
typename std::enable_if<has_curr<PortType>::value, void>::type
_set_port_value_wide(PortType& port, const ValueType& value) {
    port.next = value;
}

template<typename PortType, typename ValueType>
typename std::enable_if<!has_curr<PortType>::value, void>::type
_set_port_value_wide(PortType& port, const ValueType& value) {
    port = value;
}

int main(int argc, char** argv) {
    cxxrtl_design::p_%s %s_i; // DUT instance

    // Declare input variables
%s

    // Read input values
%s

    // Apply inputs to DUT
%s

    // Handle reset, clock toggling, and evaluation
%s

    // Write outputs from DUT
%s

    return 0;
}
`
